#!/bin/sh

# SPDX-License-Identifier: GPL-3.0
# Copyright (C) 2022-present 7Ji (pugokushin@gmail.com)

# This script is NOT part of the project ampart (https://github.com/7Ji/ampart)
# Even this script is placed in ampart package in the EmuELEC source code
# Issues regarding this script should NOT be opened on ampart's project page

# This script should NEVER be used in CoreELEC. 
# If you can see this, that means you are trying to modify this script
# I'll NEVER EVER test and debug on CoreELEC as it already has ceemmc
# Even if you made it to work on there, you should debug it yourself.
# If you want to extract and run ampart on CoreELEC, save it
# ampart is hard-coded not to run on CoreELEC
# Don't even think about opening issue on ampart to allow CoreELEC, I'll close it


# Note: It is possible to applay a global offset to ampart via an alias on the top of the script, e.g. alias ampart='ampart --offset 4M', this would only be useful if you are using a Xiaomi device as they modify the offset from standard 36M to 4M to avoid the 32M wasted between bootloader and reserved. You surely need some patches to the kernel's mmc driver for it to correctly recognize the internel emmc partition table, though. https://github.com/7Ji/HybridELEC/tree/coreelec-9.2/projects/Amlogic/devices/mibox3/patches/linux. Please be noted this is only a personal advice from me(7Ji) and doing so will end up with no support from neither Team EmuELEC nor myself.


PART_RESIZED=''
PART_MOUNTED=''

# As I think other maintainers in the future might not like big hex numbers, I'll leave them here for them to easily editted
SIZE_1K='0x400'
SIZE_1M='0x100000'
SIZE_1G=$(( $SIZE_1M * $SIZE_1K ))

# If the future maintainer decides to change the layout, they can do it here, instead of going through the whole script
PART_SYSTEM_NAME='CE_FLASH'
PART_STORAGE_NAME='CE_STORAGE'
PART_ROMS_NAME='EEROMS'

DIR_SYSTEM='/flash'
DIR_STORAGE='/storage'
DIR_ROMS="$DIR_STORAGE/roms"

PART_SYSTEM_SIZE=$(( 2 * $SIZE_1G ))
PART_SYSTEM_SIZE_HUMAN='2G'   # This is not used in any processing, just for reporting to users
PART_STORAGE_SIZE$(( 2 * $SIZE_1G ))   # The minimum size of it, and actual size of it if roms is created
PART_ROMS_OFFSET$(( 4 * $SIZE_1G ))   # Disk should be at least this size for roms partitions to be created

PART_STORAGE_SUBDIR='coreelec_storage'

DISK_SIZE_LEAST=$(( 3 * $SIZE_1G ))

DISK_DEVICE='mmcblk0'
DISK_DEVICE_PATH="/dev/$DISK_DEVICE"

DISTRO_NAME='EmuELEC'

ACTION_REVERT=''
ACTION_UPDATE=''
ACTION_UPDATE_ROMS=''
ACTION_SINGLE_BOOT=''
ACTION_SINGLE_BOOT_OLDSCHOOL=''

ESSENTIAL_FILES='aml_autoscript cfgload config.ini dtb.img kernel.img SYSTEM'
ESSENTIAL_DEVICES="$DISK_DEVICE bootloader reserved env logo misc dtb"

DIR_CACHE="$(mktemp -d)" || die 'Failed to create temporary dir for installation'  # If non-conflicting name can be ensured, it can be hard-coded here

UBOOT_EMMC_SINGLE_BOOT='run cfgloademmc'

TEA_TIME=60

SNAPSHOT=''
SNAPSHOT_HUMAN=''

ROMS_CREATE=''

PART=''

abs() { 
    [[ $[ $@ ] -lt 0 ]] && echo "$[ ($@) * -1 ]" || echo "$[ $@ ]"
}

die() {
  printf "ERROR: "
  echo $*
  exit 1
}

revert_and_die() {
  printf "ERROR: "
  echo $*
  echo "Reverting changes..."
  for i in $PART_MOUNTED; do
    umount -f "$i"
  done
  sync
  ampart --clone $SNAPSHOT &>/dev/null
  sync
  if [ "$PART_RESIZED" ]; then
    resize_part "$PART_RESIZED"
  fi
  sync
  exit 1
}

snapshot() {
  local LOG="$(ampart --snapshot /dev/$DISK_DEVICE 2>/dev/null)" || die "Failed to read partition table"
  SNAPSHOT_HUMAN="$(sed 'x;$!d' <<< $LOG)" # We can restore the part table in case something goes wrong
  SNAPSHOT="$(tail -1<<< $LOG)"
}

no_emmc_boot() {
  if grep -q "/dev/$PART_SYSTEM_NAME /flash" /proc/mounts; then 
    die "ERROR: You are running $DISTRO_NAME from EMMC. Reboot to a SD/USB installation and try again."
  fi
}

unmount_part() {
  local PART_PATH="/dev/$1"
  if grep -q "^$PART_PATH " /proc/mounts; then
    echo "Warning: partition '$PART_PATH' under $DISK_DEVICE is mounted, unmounting it..."
    umount "$PART_PATH" &>/dev/null || die "Failed to unmount partition '$PART_PATH'"
  fi
}

get_block_value() { # $1:path $2: line start  VALUE should be set at outer level
  VALUE=$(tune2fs -l $1 | grep "^$2:")
  VALUE=${VALUE##* }
  [ -z "$VALUE" ] && die "Failed to get block size/count of $1 via tune2fs"
}

e2fsck_allow_fix() {
  e2fsck -fy "/dev/$1" &>/dev/null
  local RTR=$?
  if [ $RTR == 1 ]; then 
    echo "Note: Found and fixed issues on /dev/$1"
  elif [ $RTR != 0 ]; then
    die "Failed to fsck on partition /dev/$1, there's something wrong in the partition, you may need to fix it yourself"
  fi
}

resize_part() { # $1 part name $2 size in K, we use K as 1. resize2fs does not accept byte, 2. on MB there may be difference as the part may actually assigned be on KB 3. size will definitely be multiplies of 4K, then multiplies of 1K
  e2fsck_allow_fix "$1"
  if [ "$2" ]; then
    resize2fs "/dev/$1" "$2K" &>/dev/null || "Failed to resize partition /dev/$1, may be space is not enough?"
  else
    resize2fs "/dev/$1" &>/dev/null || "Failed to resize partition /dev/$1, may be space is not enough?"
  fi
}

revertable() {
  local 



}

update_table() {
  if [ "$ACTION_REVERT" ]; then
    # Revert always happen first




  elif [ -z "$ACTION_SINGLE_BOOT" ]; then
    # Make sure space is enough for dual-boot mode
    local VALUE=''
    get_block_value "/dev/$PART_NAME"  "Free blocks"
    BLK_FREE="$VALUE"
    get_block_value "/dev/$PART_NAME"  "Block size"
    BLK_SIZE="$VALUE"
    PART_FREE=$(( $BLK_FREE * $BLK_SIZE ))
    if [[ $PART_FREE -le $PART_SYSTEM_SIZE ]]; then
      die "The free space of the last part on your emmc is too small! We need at least $PART_SYSTEM_SIZE_HUMAN free space so we can create a $PART_SYSTEM_SIZE_HUMAN $PART_SYSTEM_NAME partition after we shrink it. Boot to Android and delete some files and try again!"
    fi
    PART_SIZE="$(awk -F ':' '{print $3}' <<< $PART)"
    echo "Shrinking partition $PART_NAME by $PART_SYSTEM_SIZE_HUMAN..."
    resize_part "$PART_NAME" $(( ($PART_SIZE - $PART_SYSTEM_SIZE) / 1024 ))
    PART_RESIZED="$PART_NAME"
    ampart --update /dev/mmcblk0 ^-1:::-$PART_SYSTEM_SIZE: ^-1%:CE_STORAGE CE_FLASH::: &>/dev/null
    if [ $? != 0 ]; then
      revert_and_die
    fi
  else
    # Single boot mode
    DISK_SIZE=$(( $(cat "/sys/block/mmcblk0/size") * 512 ))
    DISK_SIZE_INT=$(( $DISK_SIZE / $SIZE_1G + 1 ))
    if [[ $DISK_SIZE -gt $PART_ROMS_OFFSET_LEAST ]]; then
        echo "Oh sweet! You emmc is larger than 4G (${DISK_SIZE_INT}G), so you can create a dedicated EEROMS partition to save your ROMs, savestates, etc"
        read -p "Do you want to create a dedicated EEROMS partition? (if not, DATA partition will fill the rest of the disk) [Y/n] " choice
        case "$choice" in
          [nN]*)
            TABLE='CE_FLASH::2G:2 CE_STORAGE:::'
            ;;
          *)
            TABLE='CE_FLASH::2G:2 CE_STORAGE::2G: EEROMS:::'
            ROMS_CREATE='yes'
            ;;
        esac
      elif [[ "$DISK_SIZE" -gt 0xc0000000 ]]; then
        echo "Oops, You emmc is only 4G, to prevent DATA from filling up, you can not have a dedicated EEROMS partition :("
        echo "Your new partition table on emmc will only contain a 2G system and a data partition to fill the rest free space"
        TABLE='CE_FLASH::2G:2 CE_STORAGE:::'
      else
        echo "Oh no! You emmc is smaller than 4G! This is impossible!"
        echo "Every Amlogic S9xxx device should have at least 4G emmc onboard!"
        echo "I'm afraid you can not install EmuELEC to internal storage :("
        echo "As this only works on emmc at least 4G :<"
        exit 1
      fi
    ampart /dev/mmcblk0 $TABLE &>/dev/null
    if [ $? != 0 ]; then
      revert_and_die
    fi
  fi
}

essential_check() {
  [ "$ACTION_REVERT" ] && return
  local PROMPT_END='does not exist, check if your installtion you booted is corrupted'
  [ ! -d "$DIR_SYSTEM" ] && die "Essential dir '$DIR_SYSTEM' $PROMPT_END"
  local ESSENTIAL_FILE=''
  local ESSENTIAL_PATH=''
  for ESSENTIAL_FILE in $ESSENTIAL_FILES; do
    ESSENTIAL_PATH="$DIR_SYSTEM/$ESSENTIAL_FILE"
    [ ! -f "$ESSENTIAL_FILE" ]; then
      die "Essential file '$ESSENTIAL_FILE' $PROMPT_END"
    fi
  done
}

can_reinstall() {
  if [[ "$SYSTEM_EXIST" || "$STORAGE_EXIST" || "$ROMS_EXIST" ]]; then
    echo "Warning: either $PART_SYSTEM_NAME, $PART_STORAGE_NAME or $PART_ROMS_NAME partition exists, you may have already installed $DISTRO_NAME (or similiar distros) to internal storage"
    if [[ "$SYSTEM_EXIST" && "$STORAGE_EXIST" ]]; then
      echo "Both $PART_SYSTEM_NAME and $PART_STORAGE_NAME exist, check if we can reinstall/refresh/replace/update the internal installation"
      local SYSFS_SYSTEM_SIZE="/sys/block/$DISK_DEVICE/$PART_SYSTEM_NAME/size"
      [ ! -f "$SYSFS_SYSTEM_SIZE" ] && die "Can not check size of $PART_SYSTEM_NAME partition, this is neccessary for us as it should be at least $PART_SYSTEM_SIZE_HUMAN for us to install"
      local PART_SYSTEM_EXISTING_SIZE=$(( $(cat "$SYSFS_SYSTEM_SIZE") * 512 ))
      printf "Internal $PART_SYSTEM_NAME partition's size is "
      if [[ "$PART_SYSTEM_EXISTING_SIZE" -ge "$PART_SYSTEM_SIZE" ]]; then
        echo "larger than or equal to $PART_SYSTEM_SIZE_HUMAN, we are good to go"
      else
        echo "smaller than $PART_SYSTEM_SIZE_HUMAN"
        die "Existing partition layout not suited"
      fi
      if [ "$ROMS_EXIST" ]; then
        UPDATE_ROMS='yes'
      fi
      UPDATE='yes'
    else
      die "Can not proceed as only one of $PART_SYSTEM_NAME and $PART_STORAGE_NAME is found, your old installation on emmc is incomplete and we can not reinstall it"
    fi
  fi
}

unmount_parts() {
  local SYSTEM_EXIST=''
  local STORAGE_EXIST=''
  local ROMS_EXIST=''
  for PART in $SNAPSHOT; do  # Part is purposedly used as a global var, it will be used later
    PART_NAME="${PART%%:*}"
    # some parts will be used by us
    if [ -z "$ACTION_REVERT" ]; then
      if [ "$PART_NAME" == "$PART_SYSTEM_NAME" ]; then
        SYSTEM_EXIST='yes'
      elif [ "$PART_NAME" == "$PART_STORAGE_NAME" ]; then
        STORAGE_EXIST='yes'
      elif [ "$PART_NAME" == "$PART_ROMS_NAME" ]; then
        ROMS_EXIST='yes'
      fi
    fi
    unmount_part "$PART_NAME"
  done
  [ -z "$ACTION_REVERT" ] && can_reinstall
}

create_ext4() { # $1: name
  mke2fs -F -q -t ext4 -m 0 "/dev/$1" -L "$1" > /dev/null || die "Failed to create an ext4 fs on '$1'"
  e2fsck_allow_fix "$1"
}

notice_populate_start() {
  echo "Populating internal $PART_NAME partition..."
}
notice_populate_end() {
  echo "Populated internal $PART_NAME partition..."
}
notice_format() {
  echo "Formatting internal $PART_NAME partition..."
}

mount_part_cache() {
  mkdir -p "$DIR_CACHE" || revert_and_die "Failed to create temp dir for '$PART_NAME'"
  PART_MOUNTED+=" $PART_PATH"
  mount -o rw "$PART_PATH" "$DIR_CACHE" || revert_and_die "Failed to mount '$PART_PATH' on '$DIR_CACHE'"
}

umount_and_sync() {
  umount "$PART_PATH" &>/dev/null
  sync
}

populate_system() {
  notice_populate_start
  notice_format
  local PART_PATH="/dev/$PART_SYSTEM_NAME"
  mkfs.fat -n "$PART_SYSTEM_NAME" "$PART_PATH" &>/dev/null || revert_and_die "Failed to create a fat fs on '$PART_PATH'"
  local DIR_CACHE="$DIR_CACHE/$PART_SYSTEM_NAME"
  mount_part_cache
  echo "Copying all system files (kernel, SYSTEM, dtb, etc) under $DIR_SYSTEM to internal $PART_SYSTEM_NAME partition..."
  cp -ra "$DIR_SYSTEM/"* "$DIR_CACHE" || die 'Failed to copy system files'
  [ "$ROMS_CREATE" ] && echo 'ext4' > "$DIR_CACHE/ee_fstype"  # Internal roms fs type should 
  umount_and_sync
  notice_populate_start
}

populate_storage() {
  notice_populate_start
  local PART_PATH="/dev/$PART_STORAGE_NAME"
  local DIR_CACHE="$DIR_CACHE/$PART_STORAGE_NAME"
  if [ "$ACTION_SINGLE_BOOT" == 'yes' ]; then
    notice_format
    create_ext4 "$PART_NAME"
  fi
  mount_part_cache
  [ "$PART_STORAGE_SUBDIR" ] && DIR_CACHE="$DIR_CACHE/$PART_STORAGE_SUBDIR"
  mkdir -p "$DIR_CACHE"
  chmod 755 "$DIR_CACHE" # Just in case, if it's already be created by some random user?
  printf "Do you want to copy your user data under $DIR_STORAGE to internal $PART_STORAGE_NAME partition? "
  [ "$ROMS_CREATE" ] && printf "(This will not include all of the stuffs under $DIR_ROMS, they will be copied to $PART_ROMS_NAME partition later) "
  read -p '[Y/n] ' choice
  case "$choice" in
    [nN]*)
      :
      ;;
    *)
      echo "Stopping EmulationStation so we can make sure configs are flushed onto disk... You can run 'systemctl start emustation.service' later to bring EmulationStation back"
      systemctl stop emustation.service
      echo "Copying user data..."
      rsync -qaHSx "$DIR_STORAGE/". "$DIR_CACHE"
      sync
      ;;
  esac
  umount_and_sync
  notice_populate_end
}

populate_roms() {
  [ -z "$ROMS_CREATE" ] && return
  notice_populate_start
  local PART_PATH="/dev/$PART_ROMS_NAME"
  notice_format
  echo "Note: $PART_ROMS_NAME on the emmc will always be formatted as EXT4, Since you can not plug the emmc to a Windows PC just like you would for a SD card/USB drive"
  create_ext4 "$PART_ROMS_NAME"
  read -p "Do you want to copy all of your ROMs, savestates, etc under $DIR_ROMS to internal eeroms partition? [Y/n]" choice
    case "$choice" in
    [nN]*)
      :
      ;;
    *)
      local DIR_CACHE="$DIR_CACHE/$PART_ROMS_NAME"
      mount_part_cache
      echo "Copying Roms, savestates, etc..."
      rsync -qaHSx "$DIR_ROMS/". "$DIR_CACHE"
      umount_and_sync
      ;;
  esac
  notice_populate_end
}

finish_work() {
  echo "All done!"
  echo "$DISTRO_NAME has been installed to your internal emmc."
  echo 
  if [ "$ACTION_SINGLE_BOOT" == 'yes' ] && /usr/sbin/fw_setenv storeboot "$UBOOT_EMMC_SINGLE_BOOT"  # this was used to boot Android, but since Android is gone, we replace to what we want for emmc boot
  echo "You'll need to poweroff the box and unplug your SD card/USB drive for the box"
  read -p "Would you like to poweroff now [y/N]? " choice
  case "$choice" in
    [yY]*)
      if /usr/sbin/fw_printenv whereToBootFrom > /dev/null 2>&1; then /usr/sbin/fw_setenv whereToBootFrom internal; fi
      /usr/sbin/fw_setenv bootfromnand 1
      /usr/sbin/reboot switch_system
      ;;
  esac
}


install_to_internal() {  # $1 single boot or not
  update_table
  echo "Warning: from this point onward, all of the changes are IRREVERSIBLE since new data will be written to emmc. Make sure you keep the power pluged in."
  echo "If anything breaks apart, you can revert your partition table with the following command, but changes to the data are IRREVERSIBLE"
  echo
  echo "ampart --clone /dev/mmcblk0 $SNAPSHOT_HUMAN"
  echo
  echo "Ready to actually populate internal EmuELEC installation in 10 seconds..."
  echo "You can ctrl+c now to stop the installation if you regret"
  sleep 10
  populate_system
  populate_storage
  populate_roms
}

no_coreelec() {
  if grep -q "^NAME=\"CoreELEC\"$" /etc/os-release ; then
    echo "Hello, Mr naughty naughty. You are trying to run this script on CoreELEC right?"
    echo "Sorry but it does not work in that way. Both the script and the tool ampart it relies"
    echo "does not work on CoreELEC and I have no interest on providing support there"
    echo "You should use ceemmc as it's the official method for CoreELEC"
    exit 1
  fi
}

cup_of_tea() {
  echo "Take a cup of tea, sit down, wait $TEA_TIME seconds, and think thoroughly"
  echo "Is this REALLY REALLY what you want?"
  sleep $TEA_TIME
}

limit_device() {
  local DT_NAME="$( /usr/bin/dtname )" &>/dev/null
  if ! [[ "$DT_NAME" =~ ^gxl_p212 ]]; then
    die "This script is only verified to work on gxl_p212 devices yet your device is $DT_NAME\n - Please wait until Team EmuELEC can verify if it works for your device"
  fi
}

mmc_drivable() {
  local ESSENTIAL_DEVICE
  echo "Checking if mmcblk0 is properly driven"
  for ESSENTIAL_DEVICE in $ESSENTIAL_DEVICES; do
    if [ ! -e "/dev/$ESSENTIAL_DEVICE" ]; then
      die "Device '$ESSENTIAL_DEVICE' under /dev is not found, either your emmc driver does not work correctly or you have a incompitable dtb"
    fi
  done
}

confirm_method() {
  if [ "$1" == "--iknowwhatimdoingandidontcareaboutupdate" ]; then # Gosh, I think such a long argument will surely stop users from doing so
    echo "WARNING: You'll install via the old-school /dev/system+/dev/data way"
    echo "You should only try this if we can't modify the part table"
    echo "to implement a custom partition layout to achive safer dual/single install"
    echo
    echo "However, doing so will both render your installtion non-upgradable and your"
    echo "Android installtion unusable even some of its partitions are still kept"
    echo 
    echo "As we'll modify the cfgload script under internal /dev/system partition,"
    echo "You'll need to modify it by YOURSELF every time you want to ugrade your OS"
    echo "as the official upgrade package will revert it back."
    echo 
    echo "Doing so is dangerous, tedious and you'll NOT receive a single support"
    echo
    cup_of_tea
    PART_SYSTEM_NAME='system'
    PART_STORAGE_NAME='data'
    ACTION_SINGLE_BOOT_OLDSCHOOL='yes'
  elif [ "$1" == "--iknowwhatimdoing" ]; then
    echo "Warning: working in single boot mode"
    echo "This script will erase the old partition table on your emmc"
    echo "and create a new part table that ONLY contains $PART_SYSTEM_NAME, $PART_STORAGE_NAME and $PART_ROMS_NAME (if emmc size big enough) partiitons"
    echo "(reserved partitions like bootloader, reserved, env, logo and misc will be kept)"
    echo "You Android installation will be COMPLETELY erased and can not be recovered"
    echo "Unless you use Amlogic USB Burning Tool to flash a stock image"
    echo "This script will install EmuELEC that you booted from SD card/USB drive."
    ACTION_SINGLE_BOOT='yes'
  elif [ "$1" == "--revert" ]; then
    echo "This script will revert your partition layout back to single-boot Android mode"
    echo "If you've installed via this script in default dual-boot mode"
    echo "The $PART_SYSTEM_SIZE_HUMAN we've taken from your data partition"
    echo "will be returned to it"
    ACTION_REVERT='yes'
  else
    echo "This script will shrink the last partition by $PART_SYSTEM_SIZE_HUMAN on your emmc"
    printf "and give it an alias name $PART_STORAGE_NAME and store your data under "
    if [ "$PART_STORAGE_SUBDIR" ]; then
      echo "a subfolder $PART_STORAGE_SUBDIR"
    else
      echo "it"
    fi
    echo "and create a new part $PART_SYSTEM_NAME to store $DISTRO_NAME's system files"
    echo "You Android installation should be safe but we can not guarantee this"
    echo "You need to make sure the data partition on your Android installtion"
    echo "has at least $PART_SYSTEM_SIZE_HUMAN free space, otherwise we can't install in this way"
  fi
  echo
  echo "WARNING: The script does not have any safeguards, you will not receive any"
  echo "support for problems that you may encounter if you proceed!"
  echo 
  read -p 'Type "yes" if you know what you are doing or anything else to exit: ' choice
  [ "$choice" != 'yes' ] && exit 0
}

main() {
  no_coreelec
  limit_device  # This is a temporary check and should be removed in the future
  mmc_drivable
  confirm_method "$1"
  essential_check
  no_emmc_boot
  snapshot
  unmount_parts
  install_to_internal
  finish_work
}

main
